Task 1
• S – Single-responsibility principle
Клас повинен мати одне завдання і виконувати функції в межах цього завдання. 
Тобто, якщо у нас є клас Кіт, то його функціями буде наприклад погратися, поспати чи поїсти, але функція погодувати кота повинна бути в класі Господар. 
Таким чином клас Кіт повинен відповідати лише за те, що робить сам кіт, а не за дотичні дії.

• O – Open-closed principle
Код повинен бути відкритим до розширення, але закритим для модифікації.
Наприклад, якщо є клас КласифікаторПродуктів, в нього є функція парсер з іфкою - якщо продукт "фрукт", то парсер відправляє його в одну категорію,
а інакше в категорію "овочі". Такий клас порушує цей принцим, бо якщо нам потрібно додати м'ясо, то необхідно змінювати код всередині. 
Правильно було б мати змогу додавати категорію продуктів ззовні.

• L – Liskov substitution principle
Клас повинен відводати абстракції, яку він імплементує.
Якщо є інтерфейс Машина, то його можуть імплементовувати автомобілі різних марок і типів, але не може імплементовувати іграшка машинка на пульт.
Для мене це принцип найкраще ілюструє фраза: 
"If it looks like a duck, quacks like a duck, but needs batteries - you probably have the wrong abstraction"

• I – Interface segregation principle
Клас не повинен бути змушеним імплементовувати функції, які він не буде використовувати.
Не варто роюити інтерфейс фігура з функціями Площа та Об'єм, а краще зробити два інтерфейси Фігура2Вимірна та Фігура№Вимірна,
щоб клас Квадрат не мусив мати непотрібну функцію об'єм.

• D – Dependency Inversion Principle
Високорівневі сутності не маюьб залежати від низькорівневих.
Наприклад високорівневий клас Водій повинен "спілкуватися" з класом Машина і здійснювати прискорення через нього.
Але не працювати на пряму з низькорівневим класом Акселератором 


Task 2
На мою думку наслідування Квадрата від Прямокутника не є порушенням принципу Лісков, адже квадрат є прямокутником і всі функції, які потрібні для прямокутника, потрібні і для квадрата.
Я не бачу проблем з таким наслідуванням, але можу припустити ситуацію, що інтерфейс Прямокутник має функцію Обернутися,
тоді, якщо Квадрат буде реалізовувати цей інтерфейс, то ця функція буде йому зайвою, такий приклад буде порушенням принципу Interface segregation principle